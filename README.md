# tcpmany

## 它是干什么用的

这是一个专门用来测试**长连接**服务器的工具，它包含一个核心的网络库和一些实例用法。

## 为什么要用它

利用这个工具，可以使用非常少的资源建立大量(数百万甚至上千万)的tcp连接，用以测试长连接服务器的性能指标(主要是指同时在线连接数)。
如果不用它，你需要克服单个客户端ip能够建立起的连接数的限制(0-65536)。
传统的方案有以下几种：

1. 分布式。每台机器能够连接6W，要想测试百万连接的压力，你需要将近20台机器
2. 配置多ip地址。这个方案可以节省机器，但是内核为tcp预留的缓冲区内存是省不了的。
3. tcpburn。这是个原理类似的工具，但是用法相当麻烦，需要提前录制tcp数据，而且每个连接都发一样的内容，无法动态调整。

## 原理

1. 提供了一个基于raw socket的网络库，用于在用户空间模拟tcp连接，由于连接是在用户空间维护的，我们可以灵活的控制每个连接消耗的内存。模拟的tcp连接与正常连接的不同之处在于，它的每个数据包的源地址是一个随机选择的ip，因此能够突破端口的限制。但是，如果源地址是随机的，那么服务器在响应这个数据包的时候，就无法把数据包发送给我们的虚拟客户端，因此我们引入了另一个程序来解决这个问题。
2. 提供了一个捕获并篡改网络数据包的程序。我们可以捕获某个服务器发送出去的数据包(通过源ip和端口)，然后交换源地址和目的地址，再把目的地址改为我们虚拟客户端的地址，这样虚拟客户端和目标服务器就可以互相通讯了。

参考下tcpburn的架构图
![架构](https://camo.githubusercontent.com/97e5d575150dbd3fd57369e6ce41807ab3b9d979/68747470733a2f2f7261772e6769746875622e636f6d2f77616e6762696e3537392f617578696c696172792f6d61737465722f696d616765732f7463706275726e2e474946)

## 使用

### 编译

需要安装cmake，c++11和libpcap

```bash
mkdir build
cd build
cmake ..
```

### 运行待测试的target server

这里用一个echo server作为示范

```bash
cd ./bin/
./fakeserver
```

### 运行redirect server

即tcpburn中所说的intercept
我这里叫redirect server
因为它的作用是截获、修改和转发数据包的

```bash
usage: ./redirect <client_ip> <server_port> <interface>
```

```client_ip```是指运行测试客户端的的地址
```server_port```是```target server```的端口号
```interface```是一个网络接口，必须要能捕获到有效的网络数据，比如eth0

### 运行模拟客户端

```bash
usage: ./connectmany <ip> <port> <count> <local_ip>
```

```ip```是指```target server```的ip地址
```port```是指```target server```的端口号
```count```是需要发起的连接数
```local_ip```是客户端连接使用的虚拟ip的起始值
之前提到客户端选择的源ip是随机指定的，实际上为了防止随机ip多现有网络造成影响，或者为了方便起见，使用了一个ip范围，这个```local_ip```就是这个ip范围的起始值
